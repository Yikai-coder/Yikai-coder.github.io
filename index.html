<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Yikai-coder&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="用作个人博客使用，记录个人技术博客。">
<meta property="og:type" content="website">
<meta property="og:title" content="Yikai-coder&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Yikai-coder&#39;s blog">
<meta property="og:description" content="用作个人博客使用，记录个人技术博客。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yikai-coder">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Yikai-coder's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yikai-coder&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Robocup2D入门笔记（2）——环境的配置与安装" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:26:02.957Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇主要介绍Robocup2D环境的配置与安装，由于笔者去年安装的时候Ubuntu还是18.04的版本，server也还是15.6.0的版本，所以介绍的时候还是以这个软件版本为准，但会尽量兼顾新版本与旧版本的不同。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>环境的安装主要分为一下几个步骤：</p>
<ol>
<li>Linux环境准备</li>
<li>必要软件库的准备</li>
<li>server及monitor的安装</li>
<li>球队的编译及上场</li>
<li>开始比赛吧</li>
</ol>
<p>下面分别来介绍：</p>
<h2 id="1-Linux环境准备"><a href="#1-Linux环境准备" class="headerlink" title="1.Linux环境准备"></a>1.Linux环境准备</h2><h3 id="1-1为什么选择虚拟机-Ubuntu"><a href="#1-1为什么选择虚拟机-Ubuntu" class="headerlink" title="1.1为什么选择虚拟机+Ubuntu"></a>1.1为什么选择虚拟机+Ubuntu</h3><p>  整个Robocup2D需要运行在Linux环境下，所以需要配置Linux的环境。配置Linux环境主要有两种方式，一种是使用虚拟机，另一种是使用双系统，当然现在Windows10中也可以使用Linux子系统，去年我们曾经尝试过使用，但后来发现并不是很完善，所以没有采用。而相比双系统，虚拟机可以在Windows系统中作为一个软件来使用，我们认为这更符合我们平常的开发使用习惯，而Robocup2D项目对性能的要求也不高，所以最后我们选择使用虚拟机来安装Linux环境。</p>
<p>Linux本身是一个开源的操作系统内核，它能够完成诸如文件管理、硬件控制、进程协调等任务，但除此之外就没有了，而这样一个系统显然不适合拿来直接使用，所以在此基础上，产生了许多Linux发行版，就是在原来Linux的内核基础上加入了常用的程序库、编译器等东西，使它更适合大众使用。值得一提的是，虽然Linux本身是开源的，但在它基础上的一些发行版是收费的，当然也有许多好用的Linux免费发行版，例如Ubuntu，CentOS，Deepin等。</p>
<p>不同的Linux发行版各有特点，详细可见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24261540/answer/80418621">不同Linux发行版的特点</a>。Ubuntu全球最热门的Linux发行版，安装简单而且有十分友好的图形操作界面，同时因为使用人数多出了问题也能比较容易查到解决的办法，所以我们选择使用Ubuntu作为Linux环境。</p>
<h3 id="1-2-具体安装"><a href="#1-2-具体安装" class="headerlink" title="1.2 具体安装"></a>1.2 具体安装</h3><p>先贴两个网址：<br><a target="_blank" rel="noopener" href="https://www.nocmd.com/windows/740.html">虚拟机资源</a><br><a target="_blank" rel="noopener" href="https://www.nocmd.com/windows/740.html">Ubuntu官方网址</a><br>分别在这两个地方下载虚拟机VMwar WorkStation以及Ubuntu。</p>
<p>之后的安装可以直接参考这篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">VMware安装Ubuntu18.04</a>。<br>但是要注意这么几个地方：</p>
<ol>
<li><p>在下面这个地方的时候可以直接选择中文，这样在后面可以不用再选择一次；<br><img src="https://img-blog.csdnimg.cn/20200926182848558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>在硬盘分区这个步骤不要按照文中的做，直接默认即可，分了之后反而可能会在后面安装必要软件库的时候把区域的空间耗完。<br><img src="https://img-blog.csdnimg.cn/20200926182108600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="需要注意的一步"></p>
</li>
<li><p>在terminal安装东西的时候可能会跳出如下的选项询问是否继续，这个时候需要手动在terminal中输入y/Y<br><img src="https://img-blog.csdnimg.cn/20200926190639854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>关于管理员权限<br>在Linux中也有类似Windows中的管理员权限，在安装软件的时候会用上，<code>sudo</code>开头的命令就是以管理员权限运行的，也可以直接输入su进入管理员模式，以后所有命令就都是管理员权限的操作。<br>但是最开始我们明明没有设置管理员，但我们在安装软件的时候却要我们输入管理员密码，这可怎么办呢？<br>可以输入下面的命令设置管理员密码<br><code>sudo passwd</code><br>注意终端里面输管理员密码是不会显示的。<br>完成之后Linux的安装这一步就算是完成了。</p>
<h3 id="1-3-Linux小试牛刀"><a href="#1-3-Linux小试牛刀" class="headerlink" title="1.3 Linux小试牛刀"></a>1.3 Linux小试牛刀</h3><p>在完成Linux安装后，可以先尝试下面这些操作来熟悉一下Linux</p>
</li>
<li><p><strong>打开终端</strong>（Terminal）<br>  打开终端有两种方式：</p>
<ol>
<li>直接在桌面打开<br><img src="https://img-blog.csdnimg.cn/20200926184154726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>通过快捷键crtl+alt+t<br>打开后是这样的<br><img src="https://img-blog.csdnimg.cn/20200926184245405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
</li>
<li><p><strong>尝试一些基础命令</strong></p>
<ul>
<li><p>首先是查看当前所在目录<br><code>pwd</code><br>  对应英语中的print working directory</p>
</li>
<li><p>接着尝试打印当前目录下的文件<br><code>ls</code><br>对应英语中的list</p>
</li>
<li><p>接着尝试移动目录<br><code>cd</code><br>对应英文为change directory<br>当然直接输入cd是不能改变目录的，必须要在后面接上一个参数告诉系统移动到哪个地方。</p>
<figure class="highlight plain"><figcaption><span>./xxxx```其中xxxx可以在刚刚ls命令打印出来的文件夹中选一个</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">	&#96;&#96;&#96;cd ..&#96;&#96;&#96;会返回上一级目录</span><br><span class="line">	**注意cd和后面的参数之间要有一个空格**</span><br><span class="line">	- 打开一个文件</span><br><span class="line">	&#96;&#96;&#96;.&#x2F;xxxx&#96;&#96;&#96;</span><br><span class="line">	注意这个文件必须在当前目录下，如果不确定可以先用ls命令查看；</span><br><span class="line">	同时文件的后缀名也要带上。</span><br><span class="line">	- 创建新目录</span><br><span class="line">	&#96;&#96;&#96;mkdir xxxx&#96;&#96;&#96;</span><br><span class="line">	对应英文make directory</span><br><span class="line">	可以创建一个名为xxxx的文件夹</span><br><span class="line">	- 创建一个文件</span><br><span class="line">	&#96;&#96;&#96;touch xxxx&#96;&#96;&#96;</span><br><span class="line">	touch命令后接的文件如果不存在则会创建，如果存在则可以修改时间等</span><br><span class="line">	- 删除文件</span><br><span class="line">		&#96;&#96;&#96;rm xxxx&#96;&#96;&#96;</span><br><span class="line">		其中xxxx为待删除的文件。当然提到删除就不得不提到著名的删库跑路公式&#96;&#96;&#96;sudo rm -rf &#x2F;*&#96;&#96;&#96;</span><br><span class="line">		![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200926204043452.png#pic_center)</span><br><span class="line"></span><br><span class="line">		![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2020092620403051.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU&#x3D;,size_16,color_FFFFFF,t_70#pic_center)</span><br><span class="line">		**不建议大家尝试，虽然只是虚拟机但是重装还是挺麻烦的**</span><br><span class="line">	- 清屏</span><br><span class="line">	&#96;&#96;&#96;clear&#96;&#96;&#96;</span><br><span class="line">	刚刚打了这么多命令整个terminal有很多东西，为了更加清晰地查看信息，使用clear命令可以把整个terminal清空。</span><br><span class="line">	- 复制与粘贴</span><br><span class="line">	在terminal中单纯的&#96;&#96;&#96;crtl+c&#96;&#96;&#96;只能用来停止进程，所以复制与粘贴得使用&#96;&#96;&#96;crtl+shift+c&#96;&#96;&#96;与&#96;&#96;&#96;crtl+shif+v&#96;&#96;&#96;。</span><br><span class="line">	</span><br><span class="line">	3. **一些有意思的操作（如果不想再浪费时间熟悉Linux可以跳过）**</span><br><span class="line">	 - 无限复读</span><br><span class="line">	 &#96;&#96;&#96;yes xxxxxxx&#96;&#96;&#96;</span><br><span class="line">	 输入下面这个命令之后可以不断地复读；</span><br><span class="line">	 - 瞅啥呢</span><br><span class="line">	 &#96;&#96;&#96;xeyes&#96;&#96;&#96;</span><br><span class="line">	 会产生一个眼睛跟着鼠标移动；</span><br><span class="line">	- 黑客入侵</span><br><span class="line">	如果看过黑客帝国会对里面的黑底绿字的代码流动界面印象非常深刻，而我们现在就可以实现这个功能：</span><br><span class="line">	首先安装一个插件&#96;&#96;&#96;sudo apt install cmatrix&#96;&#96;&#96;</span><br><span class="line">	之后直接运行&#96;&#96;&#96;cmatrix&#96;&#96;&#96;即可</span><br><span class="line">	- 可爱的小猫</span><br><span class="line">	一个小插件可以产生一只不停的跟着鼠标跑的小猫；</span><br><span class="line">	&#96;&#96;&#96;sudo apt install oneko&#96;&#96;&#96;</span><br><span class="line">	&#96;&#96;oneko&#96;&#96;</span><br><span class="line">	- 小火车</span><br><span class="line">	产生一列呼啸而过的蒸汽火车</span><br><span class="line">	&#96;&#96;&#96;sudo apt install sl&#96;&#96;&#96;</span><br><span class="line">	&#96;&#96;&#96;sl&#96;&#96;&#96;</span><br><span class="line">	- 格言警句</span><br><span class="line">	在代码写累了的时候可以看看大佬们的名言</span><br><span class="line">	&#96;&#96;&#96;sudo apt install fortune&#96;&#96;&#96;</span><br><span class="line">	&#96;&#96;&#96;fortune&#96;&#96;&#96;</span><br><span class="line">	当然也少不了唐诗三百首了</span><br><span class="line">	&#96;&#96;&#96;sudo apt install fortune-zh&#96;&#96;&#96;</span><br><span class="line">	&#96;&#96;&#96;fortune-zh&#96;&#96;&#96;</span><br><span class="line">	- 花里胡哨地打印系统信息</span><br><span class="line">	两个插件可以花里胡哨地打印系统信息</span><br><span class="line">	&#96;&#96;&#96;sudo apt install screenfetch&#96;&#96;&#96;</span><br><span class="line">	&#96;&#96;&#96;screenfetch&#96;&#96;&#96;</span><br><span class="line">	或</span><br><span class="line">	&#96;&#96;&#96;sudo apt install linuxlogo&#96;&#96;&#96;</span><br><span class="line">	&#96;&#96;&#96;linux_logo&#96;&#96;&#96;</span><br><span class="line">	- 担心错过重要日子？</span><br><span class="line">	&#96;&#96;&#96;cal&#96;&#96;&#96;</span><br><span class="line">	快速查看日期放置错过重要日子。</span><br><span class="line">	- pv命令</span><br><span class="line">	pv命令可以让输出匀速实现</span><br><span class="line">	&#96;&#96;&#96;sudo apt install pv&#96;&#96;&#96;</span><br><span class="line">	以后只要在命令的最后加上</span><br><span class="line">	&#96;&#96;&#96;| pv -qL 10&#96;&#96;&#96;即可。</span><br><span class="line">	到这里相信大家对Linux里的terminal都不那么陌生了，那么我们可以接着继续了。</span><br><span class="line">## 2.必要软件库的安装</span><br><span class="line">server需要以下这些软件库</span><br></pre></td></tr></table></figure>
<p>g++<br>make<br>boost<br>bison<br>flex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然直接安装可能会发现定位不到这些软件包，所以可以尝试下面这个命令：</span><br></pre></td></tr></table></figure>
<p>sudo apt-get update;</p>
</li>
</ul>
</li>
</ol>
<p>sudo apt-get -y install libboost-dev;<br>sudo apt-get -y install libboost-all-dev;<br>sudo apt-get -y install g++ automake;<br>sudo apt-get -y install libqt4-dev libxpm-dev libaudio-dev libxt-dev; libpng-dev libglib2.0-dev libfreetype6-dev libxrender-dev libxext-dev; libfontconfig-dev libxi-dev;<br>sudo apt-get -y install libqt4-sql-sqlite;<br>sudo apt-get -y install rar unrar p7zip;<br>sudo apt-get -y install nautilus-open-terminal;<br>sudo apt-get -y install build-essential;<br>sudo apt-get -y install flex bison tcsh;</p>
<p>sudo apt-get -y install libpng16-dev;<br>sudo apt-get -y install libpng12-dev;<br>sudo apt-get -y install libglib2.0-dev;<br>sudo apt-get -y install zlib*;<br>sudo apt-get -y install libfreetype6-dev;<br>sudo apt-get -y install libfontconfig1-dev;</p>
<p>sudo apt install -y zsh git vim #qtcreator;<br>sudo apt install -y python-setuptools python-dev build-essential;<br>sudo pip install –upgrade pip; </p>
<p>sudo rm /var/cache/apt/archives/lock;<br>sudo rm /var/lib/dpkg/lock;<br>sudo dpkg –configure -a;<br>sudo apt-get autoclean;<br>sudo apt-get clean;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在安装依赖库的时候碰到&#96;&#96;&#96;E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend - open 针对apt-get被占用的解决方案&#96;&#96;&#96;这种问题，可以尝试依次输入下面的命令：</span><br></pre></td></tr></table></figure>
<p>sudo rm /var/lib/apt/lists/lock<br>sudo rm /var/cache/apt/archives/lock<br>sudo rm /var/lib/dpkg/lock*</p>
<p>sudo dpkg –configure -a</p>
<p>sudo apt update</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## 3.server和monitor的安装</span><br><span class="line">在完成必要软件库的安装后，剩下的工作就简单多了。安装server和monitor的流程操作是一样的，所以这里将两个统一起来说。</span><br><span class="line"></span><br><span class="line">首先将下载下来的压缩包（默认是tar格式，其他格式需要采用别的方法）解压出来（如果是文件夹就不需要这个步骤）。这里可以用terminal也可以用图形化操作界面：</span><br><span class="line">1. terminal操作：</span><br><span class="line">	首先cd到压缩包所在目录，或者直接在压缩包所在目录右键选择在终端打开，之后输入&#96;&#96;&#96;tar zxvf xxxx.tar&#96;&#96;&#96;</span><br><span class="line">2. 图形化界面操作：  </span><br><span class="line">	选中文件右键打开，选择左上角提取，选择一个目录即可；</span><br><span class="line"></span><br><span class="line">接下来进入这个目录，接着打开终端，输入&#96;&#96;&#96;.&#x2F;configure&#96;&#96;&#96;。这里说明一下这个命令有什么作用：.&#x2F;configure是源代码安装的第一步，主要的作用是对即将安装的软件进行配置，检查当前的环境是否满足要安装软件的依赖关系，如果满足条件，就会生成makefile文件。其实所有的编译都是需要有一个makefile文件来指导编译链接过程的，但是在IDE中我们全权交给了IDE，所以不需要考虑，而现在我们是手动来进行这个过程。</span><br><span class="line"></span><br><span class="line">接着输入&#96;&#96;&#96;sudo make&#96;&#96;&#96;。这一步意思就是编译了。</span><br><span class="line"></span><br><span class="line">最后需要&#96;&#96;&#96;sudo make install&#96;&#96;&#96;。最后这步就是把刚刚编译好的东西给安装下来。</span><br><span class="line"></span><br><span class="line">全部完成之后，输入&#96;&#96;&#96;rcsoccersim&#96;&#96;&#96;检查安装是否成功，如果一切正常这个时候就会弹出下面的这个界面。</span><br><span class="line">![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200926200735386.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU&#x3D;,size_16,color_FFFFFF,t_70#pic_center)</span><br><span class="line"></span><br><span class="line">## 4. 球队的编译与上场</span><br><span class="line">当我们把环境以及服务器都安装好之后，我们还需要球队把比赛跑起来，所以现在介绍球队的编译与上场。</span><br><span class="line">我们在网上下载到的球队文件有两种，一种是未经封装的球队，主要是底层球队；另一种是已经经过封装的球队。这两种球队的上场与编译略有不同。</span><br><span class="line">1. 未经封装的球队</span><br><span class="line">	未经封装的球队是没有&#96;&#96;&#96;start.sh&#96;&#96;&#96;文件的，所以需要先经过编译才能运行。</span><br><span class="line">	未经封装的球队和server的安装流程类似，同样是进入文件夹，之后依次执行：</span><br></pre></td></tr></table></figure>
<pre><code>./configure
sudo make
sudo make install
```
完成之后在目录下会生成一个start.sh文件，在server已经开启的情况下，同样在这个目录下，输入：
```./start.sh```
即可把球队跑起来连接到server上。
</code></pre>
<ol start="2">
<li>已经经过封装的球队<br> 一般已经封装过的球队是会有<code>start.sh</code>的文件，通常直接运行即可。当然有的可能没有<code>.sh</code>后缀，这个时候就不需要这个后缀。</li>
</ol>
<p>但是如果只是一个球队，又不想再准备一个球队，怎样能先把比赛跑起来呢？这个时候可以把球队文件复制一份，接着在<code>start.sh</code>文件中修改teamname为另外一个球队名，就可以把这个球队再连接到服务器了。<br><img src="https://img-blog.csdnimg.cn/20200926202025122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-开始比赛吧"><a href="#5-开始比赛吧" class="headerlink" title="5.开始比赛吧"></a>5.开始比赛吧</h2><p>终于把两个球队都连接到server了，接下来到我们选中monitor界面，按下<code>crtl+k</code>，就可以开始比赛了。</p>
<p>如果想终止比赛，同样是选中monitor界面，按下<code>crtl+q</code>就可以终止比赛了。</p>
<p>最后，整个环境的配置与安装都已经完成了，当时我们在这个阶段也是经历了一段十分痛苦的过程，最后终于摸索出了这么一个办法，博客中的内容不一定正确，如果能帮到你那当然最好了，而如果发现有误，也欢迎在评论区或者私信进行讨论。</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/QZP51ZX/article/details/108047995">Linux命令大全详解，让我们轻松入门学习Linux！</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41741971/article/details/82053290?biz_id=102&utm_term=linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82053290&spm=1018.2118.3001.4187">意想不到的有趣linux命令18个，玩得溜</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/markchalse/article/details/96429786">Robocup 仿真2D 学习笔记（一） ubuntu16.04 搭建 robocup 仿真2D环境</a></li>
<li><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1109982/e-could-not-get-lock-var-lib-dpkg-lock-frontend-open-11-resource-temporari">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable) [duplicate]</a></li>
</ol>
<p>上一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/108719834">Robocup2D入门笔记（1）——概述
</a><br>下一篇：<a target="_blank" rel="noopener" href="https://editor.csdn.net/md?articleId=108969718">Robocup2D入门笔记（3）——比赛运行逻辑简介</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85/" data-id="ckmpminmg0003b8v8gvgq6uqv" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Robocup2D入门笔记（3）——比赛运行逻辑简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E6%AF%94%E8%B5%9B%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:26:02.938Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在前面的几篇博客中我们成功在自己的电脑上把比赛跑起来了，但具体怎么跑起来的我们还是不太清楚，这一篇博客就简要介绍比赛是如何跑起来的。</p>
<p>一场Robocup2D的比赛主要分为server、monitor和client三个部分。</p>
<p>在server启动之后，会开放一个端口（一般是6000）用于本地的球队连接上去，如果是联机比赛那就是走一个ip地址+端口。之后我们利用脚本(start.sh)就可以快速启动我们的球队生成12个进程（1个教练+11个球员），这些进程就能通过预先设置好的端口连接到服务器上，连接成功之后就会执行后面的代码，将球员放置到场上准备比赛，当双方都连接好之后，在server下达一个开球的指令(crtl+k)就会开启比赛。</p>
<p>在比赛的过程中，我们看起来连续的图像实际上是离散的，1秒钟被分成了10个周期（也就是100ms一个周期），因为周期时间很短所以看起来就是一个连续的过程。在每个周期中，服务器都会发送信息到各个进程中，例如当前球员所能看到的听到的东西等；而每个进程也需要发送指令到服务器端，例如转动脖子，向前冲，踢球等，发送到server的指令会被server先检查一次，而且一个周期仅能发送一定数量的指令，防止恶意堵塞信道。如此循环下去直到6000个周期跑完比赛结束。</p>
<p>而monitor则是在每个周期中把server模拟出来的场上的信息进行可视化，例如某个球员在哪，球在哪，离散的点因为周期很短所以看起来也会是连续的。</p>
<p><img src="https://img-blog.csdnimg.cn/20201023224554547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>而在client中区分出了coach和player，coach这个client并不会显示在场上，也不会参与移动、踢球等指令，但是它可以发送信息给球员，而这个信息是不会受到球场噪音的干扰的（关于球场噪音可以看下一篇），但是会受到发送频率的限制。同时client也可以获得完整的球场信息，相当于一个拥有上帝视角的client，他可以审时度势做出球队整体的策略。</p>
<p>上一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/108814256">Robocup2D入门笔记（2）——环境的配置与安装
</a><br>下一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/109263410">Robocup2D入门笔记(4)——常见模型
</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E6%AF%94%E8%B5%9B%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%E7%AE%80%E4%BB%8B/" data-id="ckmpminmb0001b8v84fl1g52c" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Robocup2D入门笔记（4）——常见模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:26:02.919Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Robocup2D中有几个常见的模型，例如听觉、视觉、移动、踢球等，这篇博客主要介绍这几个常见的模型，这些模型也都可以在官方发布的说明书中找到（<a target="_blank" rel="noopener" href="https://download.csdn.net/download/CS_Newer19885/12881411">懒得找可以点这里</a>）。</p>
<h2 id="一、球场模型"><a href="#一、球场模型" class="headerlink" title="一、球场模型"></a>一、球场模型</h2><p>Robocup2D的球场中存在一个坐标系，如下图所示，进攻方向是X轴的正方向，顺时针旋转90°后就是Y轴正方向，球场内的X的取值范围是[-52.5, 52.5]，Y的取值范围是[-34, 34]。<br><img src="https://img-blog.csdnimg.cn/20201024183215330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意左右两边的坐标轴方向是正好相反的，但是只要记住上面的坐标推导原则即可。</p>
<h2 id="二、听觉模型"><a href="#二、听觉模型" class="headerlink" title="二、听觉模型"></a>二、听觉模型</h2><h3 id="1、信息模板"><a href="#1、信息模板" class="headerlink" title="1、信息模板"></a>1、信息模板</h3><p>球员端client接受到的听觉信息会是下面这样的：<br><code>（hear Time sender &quot;Message&quot;)</code><br>其中hear是保留字，用于区分不同的信息种类；<br>Time就是收到信息的时间；<br>sender指示信息从什么哪里传过来，如果是其他球员，就指示一个方向，如果是教练，就是online_coach_left或online_coach_right，如果是裁判就是referee，如果是自己就是self。</p>
<h3 id="2、信道限制"><a href="#2、信道限制" class="headerlink" title="2、信道限制"></a>2、信道限制</h3><p>除此之外，球员在一个回合之内最多只能听到一个由球员发来的信息，也就是说，如果两个球员同时向一个球员发出信息，这个球员只能接收到其中的一个。但是由教练，自己和裁判发来的信息可以允许与球员发来的信息并存。</p>
<h3 id="3、交流范围"><a href="#3、交流范围" class="headerlink" title="3、交流范围"></a>3、交流范围</h3><p>球员只能听到一定范围之内的信息，例如在己方球门的守门员说出的信息在前场的前锋就不能够听到了，这个距离是50个单位长度，也就是一个球员可以听到在这个范围内的一个球员发来的信息，而在这个范围以外的球员发出信息他就听不到了。</p>
<h2 id="三、视觉模型"><a href="#三、视觉模型" class="headerlink" title="三、视觉模型"></a>三、视觉模型</h2><h3 id="1、信息模板-1"><a href="#1、信息模板-1" class="headerlink" title="1、信息模板"></a>1、信息模板</h3><p><code>(see ObjName Distance Direction DistChng DirChng BodyDir HeadDir)</code><br>see是保留字表示是视觉信息；<br>ObjName表示看到的物体是什么，注意在Robocup2D中，球员得自己通过观察到的球场上的标志物来推断自己的位置，服务器并不会将球员的坐标直接发送给球员；<br>Distance就是距离；<br>Direction就是方向；<br>DirChng，如果将两个物体连线看成一个向量，DirChng指的就是这个向量的模；<br>BodyDir和HeadDir就分别指的是当前球员身体和头的方向。</p>
<h3 id="2、视觉范围"><a href="#2、视觉范围" class="headerlink" title="2、视觉范围"></a>2、视觉范围</h3><p>视觉的范围判定会比听觉要更加复杂一点。<br>球员所能看到的反围是当前头所在方向的一个扇形，这个角度被称为view_angle，这个角度可以有多种不同的取值，当然大角度对应的需要更长的周期才能获取到信息。<br>接着球员所能看到的东西也会随着距离的不同而不同，主要有unum_far_length,unum_too_far_length, team_far_length, team_too_far_length，这里分别介绍。<br>当dist&lt;unum_far_length时，球员可以看到所在区域的球员的所属球队和号码；<br>当unum_far_length&lt;dist&lt;unum_too_far_length时，球员有一定的概率能够看到号码，但是依然可以识别出所属球队；<br>当unum_too_far_length&lt;dist&lt;team_far_length时，球员无法看到号码，但可以识别出球队；<br>当team_far_length&lt;dist&lt;team_too_far_length时，球员有一定概率可以分辨出所处球队；<br>当dist&gt;team_too_far_length时，球员就无法识别出所属球队了。<br><img src="https://img-blog.csdnimg.cn/20201024185411862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3、噪音"><a href="#3、噪音" class="headerlink" title="3、噪音"></a>3、噪音</h3><p>球员的视觉信息会收到噪音的影响，而这个噪音的影响着球员对距离的判断，而且距离越远噪音越大。</p>
<h2 id="四、动作模型"><a href="#四、动作模型" class="headerlink" title="四、动作模型"></a>四、动作模型</h2><p>动作模型有很多，大家具体可以去看说明书，这里只挑几个重要的说明</p>
<h3 id="1、移动模型"><a href="#1、移动模型" class="headerlink" title="1、移动模型"></a>1、移动模型</h3><h4 id="1-1-球员移动"><a href="#1-1-球员移动" class="headerlink" title="1.1 球员移动"></a>1.1 球员移动</h4><p>球员的移动取决于球员发出的指令，如果球员发送dash指令，那么球员就会向前加速或者减速（向后dash），而如果没有发送dash指令就会按照一定的比例衰减速度。</p>
<h4 id="1-2-球的移动"><a href="#1-2-球的移动" class="headerlink" title="1.2 球的移动"></a>1.2 球的移动</h4><p>球的移动与球员的移动类似，也是如果没有人踢球，就会保持当前的方向移动，速度不断衰减，而如果有人踢就会获得一个新的速度与角度。</p>
<h4 id="1-3-噪音"><a href="#1-3-噪音" class="headerlink" title="1.3 噪音"></a>1.3 噪音</h4><p>移动模型中同样有噪音的影响，为了模拟现实世界中那些没有被预料到的移动。</p>
<h3 id="2、碰撞模型"><a href="#2、碰撞模型" class="headerlink" title="2、碰撞模型"></a>2、碰撞模型</h3><p>碰撞模型主要针对两个物体重叠的情况，当发生这种情况的时候，系统判定为发生碰撞，两个物体都会沿着来时的路径被移动开直到两者不再重叠，同时速度都乘以-0.1</p>
<h3 id="3、体力模型"><a href="#3、体力模型" class="headerlink" title="3、体力模型"></a>3、体力模型</h3><p>球员是有体力限制的，而体力就被存储在一个叫体力池的地方，当球员发送dash指令的时候就会从体力池中减少体力。<br>但同时每个回合球员都会获得一些体力的恢复，甚至在有些时候球员的缓慢移动能够恢复体力（也就是才场上散步了）。而如果球员的体力消耗到一定程度了，它就无法再做快速的移动只能缓慢移动，直到体力逐渐恢复。</p>
<p>上一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/108969718">Robocup2D入门笔记（3）——比赛运行逻辑简介</a><br>下一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/109606127">Robocup2D入门笔记（5）——agent2d球队结构
</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/" data-id="ckmpminme0002b8v81uyb1v9e" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Robocup2D入门笔记（5）——agent2d球队结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94agent2d%E7%90%83%E9%98%9F%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:26:02.899Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇博客将重点介绍agent2d这个底层球队，agent2d本身也是当前最常用的一个底层球队，是helios团队开发出的底层球队，方便我们能够快速上手，将自己的想法付诸实践。<a target="_blank" rel="noopener" href="https://zh.osdn.net/projects/rctools/releases/p4887">点击进入下载地址，</a>注意要先安装librcsc然后再安装agent2d的球队代码。</p>
<h1 id="一、球队框架"><a href="#一、球队框架" class="headerlink" title="一、球队框架"></a>一、球队框架</h1><p>agent2d的框架可以看下面这张图片：<img src="https://img-blog.csdnimg.cn/20201110200351492.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到，agent2d总共有3个开始入口，分别是start.sh,start_offline.sh以及train.sh，分别对应普通模式开始，离线状态开始以及训练模式开始。</p>
<p>通过上面的脚本，开始运行main_player.cpp以及main_coach.cpp，这里面只用一个main函数，用于创建client并连线到服务器，从这里开始后面的一系列初始化的过程。</p>
<p>下一层级为samplePlayer以及sampleCoach，这个类可以认为是球员以及教练的大脑，球员类从这里衍生出了交流类（communication）、世界模型类（worldModel）、行为类（behavior）、策略类（strategy）、角色类（role）等，之后会详细介绍。</p>
<p>再往下是playerAgent类，这个类可以被认为是球员的身体类，它负责支配球员做出各种简单的动作，例如转身、踢球等。</p>
<p>最底层是soccerAgent以及basicClient类。soccerAgent类负责处理服务器发来的各种信息，例如比赛开始、比赛中止等；而basicClient类负责与服务器完成通信，从上层接收并发送指令到服务器，将服务器发来的信息上传到上层类。可以认为soccerAgent类就是介于底层通信类和上层抽象球员类之间的一个桥梁</p>
<h1 id="二、交流类"><a href="#二、交流类" class="headerlink" title="二、交流类"></a>二、交流类</h1><p>这里的交流类指的是球员之间以及球员和教练之间的交流，可以主要分为三个部分，分别是信息类（xxxMessage）、信息处理类（xxxMessageParser)以及其他类；</p>
<p>在agent2d的球员交流之中，球员之间是用固定的信息模板来进行交流的，agent2d自带了一些固定的信息模板，例如要发送球的位置信息就得调用球的信息类来生成信息，生成一个带有固定前缀码（1个char）以及固定长度的信息，这里面就涉及信息的编码了；之后信息处理类先判断发送来的信息是否符合对应的要求（前缀码和长度），然后再对信息进行解码，获得信息并记录到memory类当中。</p>
<h1 id="三、世界模型类"><a href="#三、世界模型类" class="headerlink" title="三、世界模型类"></a>三、世界模型类</h1><p>世界模型类（worldModel）是agent2d的一个非常重要的类，主要的功能就是记录球场的各种状态，例如球的位置，队友的位置，对手的位置，当然这里记录的信息是球员通过视觉或者听觉获得的，并不一定是正确的，会有一定的限制和偏差。</p>
<p>它下设了各种各样的object用于例如记录球以及队友对手的各种属性等等，而这些object类又是继承于AbstractObject类。</p>
<h1 id="四、策略类"><a href="#四、策略类" class="headerlink" title="四、策略类"></a>四、策略类</h1><p>策略（strategy）在agnet2d中指的是球队层面的一些战术配合，例如阵型、角色分配等。</p>
<p>agent2d的阵型采用的是DT跑位，这里有必要多介绍一下跑位的相关知识。在Robocup2D的历史中，最开始是没有跑位的，这个时候球员基本都是追着球跑，没有什么战略性可言。之后随着项目的发展，出现了第一种跑位方式——SBSP，基于吸引子与排斥子的跑位，简单的说就是根据球的位置算出一个当前的跑位点，这样大家就不会一窝蜂的去追球了。之后继续发展，出现了DT跑位，通过delauny三角形先把球场划分开，然后以球在这些划分的三角形的交点处为情况设置阵型，而球不在交点的时候就采用三个交点的情形按比例计算出跑位点，<a target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201601&filename=1015624092.nh&v=AREn%25mmd2FqqQWB83e7Yze9xBqJjvoI8U4eKiL1oICxtXLv3EEj3vmetMRXFP4%25mmd2BAUHqns">具体可以看这篇文章</a>。agent2d采用的是后一种办法。对应的类就是DTFFormation类，agent2d也封装了其他的跑位类，但是没有调用，而这些类都是基于SampleFormation继承而来的。</p>
<p>role类的话就是各种各样的球员角色了，例如守门员、前锋等，不同的角色会有不同的行为。</p>
<h1 id="五、行为类"><a href="#五、行为类" class="headerlink" title="五、行为类"></a>五、行为类</h1><p>行为（behavior）在Robocup2D中可以认为是一系列动作（action）的组合，例如踢球是一个动作，但射门就是一个行为，因为射门需要首先确定踢球的角度力度等，踢这个动作只是简单的一环。</p>
<p>agent2d中封装好了许多动作和行为，行为类会调用对应的动作类。如果要修改推荐也是从行为上修改，修改动作相对来说效果并不会非常明显。</p>
<p>上一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/109263410">Robocup2D入门笔记(4)——常见模型
</a><br>下一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/111238376">Robpcup 2D入门笔记（6）——总结及后续</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94agent2d%E7%90%83%E9%98%9F%E7%BB%93%E6%9E%84/" data-id="ckmpminmh0004b8v864rjgub8" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Robpcup 2D入门笔记（6）——总结及后续" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/Robpcup%202D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E5%8F%8A%E5%90%8E%E7%BB%AD/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:26:02.877Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、-总结"><a href="#一、-总结" class="headerlink" title="一、 总结"></a>一、 总结</h1><p>Robocup 2D是一个基于C++的机器人足球模拟项目，球队通过开发程序实现一个能够与服务器进行交互的球队，因为开始时间较早，所以现在已经有了非常成熟的发展了，但发展成熟的代价就是新手入门会有很大的障碍，而通过本系列博客，我希望能够让新手在入门的时候能够有一个参考，虽然这些博客不能解决所有的问题，但希望能够让他作为一块敲门砖，让新手能够快速上手。</p>
<p>在接这个项目的时候我只是一名大一的新生，当时我还对这样一个项目没有什么概念，觉得这个东西应该会很好玩，而且也很有挑战性，甚至想着未来或许还能参加Robocup的比赛。但现实很快给我浇了盆冷水，当我忙活了接近2个月才把linux环境装好，运行环境装好，让球队顺利跑起来的时候，我就隐约意识到事情不对，再加上小组合作效果不好和疫情在家的影响，实际上项目做出来效果并不理想…不过现在总算是结束了，我也希望通过这些博客能够补充Robocup 2D在中文资料上的不足，给新手一个更友好的切入点，能够更好地把精力投入到球队的开发当中，也算是了却了我的梦想。</p>
<h1 id="二、后续"><a href="#二、后续" class="headerlink" title="二、后续"></a>二、后续</h1><p>那么对于看完我博客的人，如果你坚持希望继续在这个领域做的话，那么下面的几点建议或许可以用得上：</p>
<ul>
<li>如果能够联系到有过相关经验的人，一定要好好把握，他们能够帮助解决很多问题，特别是前期的许多问题，他们往往也是踩着坑过来的，所以很多问题可能你抓破脑袋都想不出来他们可能能够很容易解决。</li>
<li>不要害怕英语阅读。Robocup2D在国内的资料目前还是不太充足，包括球队的TDP也要用英文来写，所以英文肯定是在这个项目中不可避免会碰到的，首先要克服对英文的恐惧，其实习惯了之后就会发现英文和中文一样只是信息传递的工具，并没有太多的不同，所以克服英语阅读的恐惧非常重要，不要总是想着使用翻译！！！</li>
<li>善用搜索引擎。搜索引擎的功能是很强大的，如果国内找不到合适的资料，Google或许是一个可行的选择，向stack overflow上就经常能找到许多问题的解决办法，而这需要英文阅读的能力，所以还是练好英语吧。</li>
<li>学会阅读文档等系统性文章。虽然博客可以解决局部的问题，但是很多时候要想真正对一个东西有一个系统全面的了解，还是要阅读系统文章以及原始资料，比如在这个项目中，Robcup2D官方的tutorial肯定是逃不开的，而读完这个之后你会发现会对整个项目有一个全新的认识，之后再去开发就会变得简单起来。</li>
</ul>
<p>上一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/109606127">Robocup2D入门笔记（5）——agent2d球队结构</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/Robpcup%202D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E5%8F%8A%E5%90%8E%E7%BB%AD/" data-id="ckmpminmj0005b8v8h6ze3spf" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Robocup2D入门笔记（1）——概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:26:02.853Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我个人不是Robocup2D的专业选手，仅仅是在大一刚入学就接手了这项难度很高的项目，很多东西我也是在摸索当中逐渐总结出来的，希望能帮到同为入门的其他人，毕竟对初学者而言Robocup2D的资料确实挺难找，想要系统的了解需要耗费大量的时间和精力。文中难免出现错误，希望看到的各位大神能够帮忙在评论区指正，也是对新手的很好的教学。<br>目前打算做一套比较完整的入门笔记，从是什么开始，到基础知识的介绍，软件及环境的安装，球队的基本组成，以及常用的开发工具的介绍，希望给新手提供一个全套的教程顺利渡过前期最艰苦的时期。</p>
<h2 id="1-什么是Robocup2D"><a href="#1-什么是Robocup2D" class="headerlink" title="1. 什么是Robocup2D"></a>1. 什么是Robocup2D</h2><h3 id="1-1-Robocup"><a href="#1-1-Robocup" class="headerlink" title="1.1 Robocup"></a>1.1 Robocup</h3><p>Robocup是一项非营利性的科学挑战，目标是在2050年实现组建一支机器人足球队在世界杯赛场上战胜人类队伍，目前该项目已经进行了20余年。而在原来的足球的基础上，现在逐渐发展出其他许多不同的应用场景，例如家庭工作、救援等任务。详情见官网。<br><a target="_blank" rel="noopener" href="https://www.robocup.org/">Robocup的官网</a><br><img src="https://img-blog.csdnimg.cn/20200921214239214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200921214338667.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-2-Robcup2D"><a href="#1-2-Robcup2D" class="headerlink" title="1.2 Robcup2D"></a>1.2 Robcup2D</h3><p>Robocup2D是机器人足球的模拟比赛，足球赛的模拟分为2D与3D两种，其中2D历史更加悠久，是最早开始的比赛之一，而3D近年来也取得了长足的发展，相比2D也跟加贴近真实。<br><img src="https://img-blog.csdnimg.cn/2020092121442163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里重点介绍2D比赛。2D比赛经过二十多年的发展，已经逐渐成为一项战术策略非常成熟的赛事了，许多人类足球的战术策略都被用到了这里面，例如阵型、盯防、跑位、角球战术等，而2D的限制使得在比赛中位置更加重要（因为球和球员都只能在2D的赛场上移动，因此占住了位置就是卡死了进攻以及防守的线路）。</p>
<p>而当前世界上Robocup2D的顶尖球队有这么几支：来自日本的Helios，来自中科大WrightEagle，以及来自安徽工业大学的YuShan，其中Helios的开源底层代码agent2d是现在非常多球队的底层代码，是一套功能十分完善、适合开发的代码。这里顺便提一下，因为Robocup是一项研究型项目，所以代码的复用是被赛事官方所鼓励的，但是也不能直接全盘照抄（这种事发生过），赛事组委会赛后会询问你球队做了哪些改进。</p>
<h2 id="2-关于Robocup2D的一些资源"><a href="#2-关于Robocup2D的一些资源" class="headerlink" title="2 关于Robocup2D的一些资源"></a>2 关于Robocup2D的一些资源</h2><p>国内虽然有Robocup2D的强队，但适合的资源数量不多，在这里统一整理一下：<br><a target="_blank" rel="noopener" href="https://ssim.robocup.org/">Robocup2D赛事官网</a>.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rcsoccersim/">Robocup2D基础软件的GitHub地址</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/bcahlit/robocup2d_env_install?_from=gitee_search">Gitee的软件地址</a>如果忍受不了Github的下载速度也可以尝试这个，里面还集成了一键安装的脚本，可以实现傻瓜式安装</p>
<p><a target="_blank" rel="noopener" href="http://archive.robocup.info/Soccer/Simulation/2D/">官方发布的资料</a></p>
<p><a target="_blank" rel="noopener" href="http://ai.ustc.edu.cn/2d/">中科大的教程</a></p>
<p><a target="_blank" rel="noopener" href="http://robot.hfut.edu.cn/shiyanshi/e/zydownloadlist.jsp?headid=28">Yushan的教程</a></p>
<p><a target="_blank" rel="noopener" href="https://herodrigues.me/robocup2d-tutorial/index.html">agent2d的说明网站，不是很详细</a></p>
<p><a target="_blank" rel="noopener" href="https://i.getshell.cn/tags/robocup/">博主九月大人的博客</a><br>最开始就是从这个博主的博客中对Robocup的代码有了一点认识才逐步入了门。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43665369/article/details/89931833">同样一个csdn的博主介绍agent2d的构成</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/markchalse/category_9147029.html">同样在做Robocup2D的博主，也是少见的近来还有更新的</a></p>
<h2 id="3-Robocup2D需要哪些知识"><a href="#3-Robocup2D需要哪些知识" class="headerlink" title="3 Robocup2D需要哪些知识"></a>3 Robocup2D需要哪些知识</h2><h3 id="3-1-Linux操作系统"><a href="#3-1-Linux操作系统" class="headerlink" title="3.1 Linux操作系统"></a>3.1 Linux操作系统</h3><p>Robocup2D的服务器是运行在Linux操作系统下的，所以所有球队几乎都会在Linux环境下开发、编译、运行，所以需要掌握Linux操作系统的一些简单操作，例如编译、安装、运行等。</p>
<h3 id="3-2-C"><a href="#3-2-C" class="headerlink" title="3.2 C++"></a>3.2 C++</h3><p>在Robocup2D当中，目前最主流的编程语言还是使用C++，当然也有部分球队会选择使用Java或者python，但是目前最主流的球队还是使用C++进行开发，特别是适用范围最广的Helio底层球队Agent2d是用C++进行开发，所以掌握C++的知识是很重要的。如果同样是大一初学刚刚学完一门编程语言（特别是用C语言入门的学生），那么在学习的时候需要把重点要放在C++中STL库的学习以及面向对象编程的学习。</p>
<h3 id="3-3-Git"><a href="#3-3-Git" class="headerlink" title="3.3 Git"></a>3.3 Git</h3><p>Git对于程序员来说是一个很重要的工具，特别是在多人协同开发的时候更是需要有一个强大的工具来管理每个人写的代码，Git就是一个很好的工具。关于Git的使用网上已经有很多教程了，从cmd界面到GUI界面的都有很多资料，这里就不做赘述了。</p>
<h3 id="3-3-检索资料的能力"><a href="#3-3-检索资料的能力" class="headerlink" title="3.3 检索资料的能力"></a>3.3 检索资料的能力</h3><p> Robocup2D的资料在网上其实是比较难找的，许多文章都是介绍到安装环境就截止了，少有的代码介绍和球队开发的介绍其实都不太足够而且比较零散，这个时候就需要有强大的信息检索能力，能够在众多杂乱的文章中提取出信息加以整合变成自己的知识。<br> 关于检索资料，可以尝试使用不同的搜索引擎进行搜索，采用更高效的搜索技巧来搜索资料，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28013848/answer/626643618">详情可以看这篇文章</a>。甚至在必要的时候可以科学上网在外网找资料，当然这也就需要下面这个能力。</p>
<h3 id="3-4-英文能力"><a href="#3-4-英文能力" class="headerlink" title="3.4 英文能力"></a>3.4 英文能力</h3><p> Robocup毕竟是国外的比赛，甚至连说明书也都是用英文写的，很多的资料也都会使用英文，所以强大的英文能力以及对英文的熟练程度会很大程度上影响进程，当然这次项目也培养了我不惧怕英文的能力😂</p>
<h3 id="3-5-阅读代码能力"><a href="#3-5-阅读代码能力" class="headerlink" title="3.5 阅读代码能力"></a>3.5 阅读代码能力</h3><p> 阅读代码对程序员来说是一个必不可少的过程，而在Robocup2D的开发过程中不可避免地就会要读代码，这对前期上手是非常重要的，但是常用的agent2d的代码就已经有10万行了，涉及到的文件更是非常繁多，所以沉住气读懂代码也是很重要的一环。以后会出一期博客介绍agent2d的结构以及代码构成，给有需要的人参考。</p>
<h3 id="3-6-心理方面"><a href="#3-6-心理方面" class="headerlink" title="3.6 心理方面"></a>3.6 心理方面</h3><p> Robocup2D确实是一个非常复杂的项目，面对大量的代码，大量的文件，彼此之间还相互连接牵扯，对初学而言确实打击很大，所以需要有对抗挫折的能力以及在繁杂的事物中抽丝剥茧梳理的能力，但是只要开始走起来了，其实很多东西都会迎刃而解变得越来越简单，希望大家都能享受这样一个学习进步的过程。</p>
<h1 id="4-Robocup2D是怎么运作的"><a href="#4-Robocup2D是怎么运作的" class="headerlink" title="4 Robocup2D是怎么运作的"></a>4 Robocup2D是怎么运作的</h1><p>这里仅仅简要的介绍一下整个程序是怎么运行的，具体的运行流程会在后面详细介绍。</p>
<p>简单地说，就是先开启一个叫做server（服务器）的进程（可以看作一个程序），这个进程负责模拟场上的情况，也包括和比赛双方进行通信。而在此基础上，官方开发了一个monitor（监视器），用于把server模拟出的数据做一个可视化的处理展现在一个“球场”上。而我们要做的，就是开发一个程序，这个程序可以与server进行通信，接受server传来的信息，做出决策，然后给server重新发送命令让server去模拟。而更具体的，我方的11个球员实际上是独立的11个进程，被称为client（客户端），每一个client都具有完整的接收信息做出决策的能力，同时这些client之间<strong>不可以私自进行通信</strong>，其实就是模拟了11个独立的球员，人家不可能心有灵犀对吧😀。球员（或者说client）之间的通信同样得走server，然后再通过server发送给其他球员。<br><img src="https://img-blog.csdnimg.cn/2020092616571928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下一篇：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CS_Newer19885/article/details/108814256">Robocup2D入门笔记（2）——环境的配置与安装</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/" data-id="ckmpminlt0000b8v8fqdegtjo" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-从零开始学习Git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Git/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:25:56.898Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[TOC](0 目录)</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><ul>
<li><p>Git是什么<br>  Git是一个免费开源的分布式版本管理系统。所谓版本管理系统，就是让我们能够在开发的时候更好地进行产品的迭代升级，以及回滚纠错，同时不需要冗长的命名，试想如果按照下图这样进行版本迭代该多头疼。也很容易发生错误。<br>  <img src="https://img-blog.csdnimg.cn/20210226091123991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="抖个机灵"></p>
</li>
<li><p>Git的特点</p>
<ol>
<li>分布式<br>Git的一大特点是其分布式的结构，所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这也增加了本地存储空间的占用。</li>
<li>程序员导向<br>Git毕竟是一个面向程序员开发的软件，随处都可见程序员的思维习惯，黑色的命令行框框、晦涩难懂的正则表达式，导致普通人很难上手。虽然现在已经有不少带GUI界面的Git操作软件，但从原始Git中继承来的名词和繁杂的操作还是容易让人望而生畏。</li>
<li>较陡峭的学习曲线<br>上面提到Git程序员导向的整体气质，对许多刚接触Git的程序员来说，其学习曲线也是十分陡峭的，稍不留神就容易导致各种警告和冲突的出现，特别是如果在开发的过程中碰到问题则更让人抓狂，最后可能就会变成下面的漫画那样。<br><img src="https://img-blog.csdnimg.cn/20210226093826628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>确实这种操作也是Git新手很容易出现的，毕竟我只是想拿来进行版本控制结果跳出了一大堆看不懂的错误，最简单粗暴的办法就是删了重装，但还是希望读者在看完这篇博客回去实践的时候，出现问题多想办法，总结错误，在这个过程中也能加深对Git的认识。当然最后如果实在时间紧急那还是删了重装吧😂。</li>
</ol>
</li>
<li><p>Git的故事<br>  关于Git的来源还有一个小故事。在Linus大神组织全世界的热心志愿者开发Linux系统的时候，同样面临着版本迭代控制的问题，而在Git发明之前，全世界的志愿者都是通过电子邮件将自己开发后的代码的diff，也就是修改的部分发给Linus，然后再由Linus手动进行代码合并，这样的效率显然是十分低下的，而在当时网络带宽的限制下，免费的分布式版本控制系统CVS、SVN之流速度非常缓慢，也遭到了Linus的弃用。手动合并的方式虽然繁琐，但是在Linux系统初期代码量还比较小的情况下还是能用的，但到了Linux系统十周年的时候，整个系统的代码量已经非常庞大了，再继续使用这种办法显然不是可行之举。恰逢此时有一家商用的版本控制系统公司BitMover愿意免费授权他们的产品Bitkeeper这些开发者使用，于是Linux社区开始使用这个产品进行版本控制。但是在Linux这个免费开源的系统的开发过程中竟然使用的是一个商用的版本控制系统，这在社区当时也引起了很大的争议，也有部分开发者对其进行逆向工程希望破解。最终这一行为被BitMover公司发现并取消了其授权，而Linus大神则在<strong>两个星期</strong>的时间里就重新用C语言开发出了Git这个传奇的版本控制系统，这就是Git的由来故事。<a target="_blank" rel="noopener" href="http://www.path8.net/tn/archives/6039">点击查看更加详细的故事</a></p>
</li>
</ul>
<h2 id="2-Git基本概念"><a href="#2-Git基本概念" class="headerlink" title="2 Git基本概念"></a>2 Git基本概念</h2><p>在对Git有了一个简单的认识之后让我们来先了解一些Git的基本概念，方便后续的讲述。</p>
<ul>
<li>三个区域<br>在一个Git工作目录下，总共有3个区域，分别是工作区（working directory）、缓存区（stage）、版本库（repository），工作顾名思义就是当前你看到的文件夹中的文件以及正在修改的文件，而缓存区则是一个隐藏起来的区域，你可以通过Git命令将某个经过修改的文件从工作区转移到缓存区，而版本库则是记录之前版本的区域，你可以通过Git命令来将当前缓存区中的文件打包保存成一个新的版本，注意不在缓存区中的文件则是保持与上一个版本相同。</li>
<li>五种文件状态<br>在一个Git工作目录下，每个文件都会有四种状态，分别是未追踪（untracked）、未修改（unmodified）、修改（modified）、暂存（staged）、提交（committed），而后面四种可以被认为是已追踪的状态（tracked）。在Git的工作目录中，我们需要手动将新的文件“告诉”Git，也就是让Git能够去“追踪”这个文件，关注其是否被修改提交等。而列入追踪的文件如果没有发生修改则处于未修改状态，一旦这个文件发生了变化，则状态变为修改，此时这个文件可以被存入缓存区，进入暂存状态，而一旦我们将缓存区中的内容进行提交，则文件进入暂存区称为一个历史文件，直到下一次其发生变化。详情可见下图<br><img src="https://img-blog.csdnimg.cn/20210226101200596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>HEAD<br>HEAD是一个常见的GIt概念，它其实就是一个指针，指向某一次提交，一般而言它会随着一条提交链而移动指向最新的一次提交。</li>
<li>常见符号及命令行操作<br>Git中有几个常见的符号：<ol>
<li><code>.</code>指所有可操作的文件，一般我们在将某一个版本的文件提交称为一个新的版本的时候会用这个可以省去一个个敲入需要更新的文件。</li>
<li><code>^</code>一般和HEAD配合使用，<code>HEAD^</code>指HEAD的前一个版本，<code>HEAD^^</code>指HEAD前两个版本，而如果需要更多的版本则可以用<code>HEAD~n</code>来指向。</li>
</ol>
</li>
<li>Git与Github<br>Github是一个大型代码托管平台，其实是许多远程仓库的所在网站，我们也可以把自己的远程仓库建立在上面，更详细的情况可以看下文远程仓库的部分。<h2 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3 Git安装"></a>3 Git安装</h2><h4 id="3-1-Linux系统"><a href="#3-1-Linux系统" class="headerlink" title="3.1 Linux系统"></a>3.1 Linux系统</h4>如果是在Linux系统下可以直接通过命令行进行安装，例如Debain系下的可以通过<code>sudo apt-get install git-all</code>来实现安装。<h4 id="3-2-Windows系统"><a href="#3-2-Windows系统" class="headerlink" title="3.2 Windows系统"></a>3.2 Windows系统</h4>Windows系统下可以在<a target="_blank" rel="noopener" href="https://git-scm.com/">Git的官网</a>下安装，下载完成之后一路next即可完成安装。<h2 id="4-Git基本操作"><a href="#4-Git基本操作" class="headerlink" title="4 Git基本操作"></a>4 Git基本操作</h2>下面介绍Git的基本操作，首先介绍本地Git仓库的操作，再介绍与远程仓库的连接与交互。<h3 id="4-1-基础操作"><a href="#4-1-基础操作" class="headerlink" title="4.1 基础操作"></a>4.1 基础操作</h3></li>
</ul>
<ol>
<li><p>初始化仓库<br><code>git init</code><br>这个命令没有太多可说的，直接使用即可，之后在文件夹中会生成一个<code>.git</code>的隐藏文件夹，这个文件夹就是用于保存这个Git工作目录的相关信息的，随着开发的进行这个文件夹的大小会逐渐膨胀。</p>
</li>
<li><p>将文件保存到缓存区<br>在初始化完成之后，如果当前文件夹中原来有部分文件，则需要手动将已有文件添加到缓存区当中（同时也是将这些文件标记为追踪状态），可以通过下面的命令：<br><code>git add [filename|dir|.]</code><br>来实现，其中如果使用<code>.</code>作为最后的参数则会把当前文件夹中的所有文件添加进去。而如果有多个文件或文件夹则文件与文件之间直接使用空格隔开即可。</p>
<p> 如果想把文件从缓存区中删除则可以使用下面的两条命令：<br> <code>git rm --cached [filename] or git rm -r --cached [dir|.] </code><br> <code>git reset &lt;HEAD|log&gt; [filename]</code>这条命令的意思是用版本库中的对应文件来替换当前的缓存区，从而实现相同的效果。</p>
</li>
<li><p>查看文件状态<br>如果想要查看当前文件夹中的文件状态，可以通过<br><code>git status [|filename]</code><br>实现。如果参数为空则会列出当前目录下所有的文件状态。</p>
</li>
<li><p>查看同一文件不同版本之间的不同<br> 通过以下命令可以查看同一文件不同版本之间的不同：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff [filename] 查看当前工作区文件和暂存区的不同</span><br><span class="line">git diff HEAD [filename] 查看工作区和之前已提交的不同</span><br><span class="line">git diff [HEAD|log] [HEAD|log] [filename] 查看两个不同版本之间的不同</span><br><span class="line">git diff --cached [HEAD|log] [filename] 查看暂存区和已提交文件的不同</span><br></pre></td></tr></table></figure>
<p> 敲入命令后会出现以下这样的界面：<br> <img src="https://img-blog.csdnimg.cn/2021022611042295.png" alt="在这里插入图片描述"><br>红色和绿色表示的就是两个文件之间的差异，其中— a表示的是修改前的文件，而+++ b表示修改之后的文件。下面的红绿字体同样对应，红色字前有一个<code>-</code>表示这是修改前的内容，绿色字体前<code>+</code>表示这是修改后的内容。</p>
</li>
<li><p>签出命令<br> 签出命令对应的是<code>git checkout</code>，这个命令有多个用途。</p>
<ol>
<li>切换分支<br>通过<code>git checkout [branch]</code>可以在不同的分支之间切换，详情见下文分支操作部分。</li>
<li>取出文件进行覆盖<br>签出命令可以将文件从缓存区取出到工作区，也可以从版本库中取出来覆盖缓存区和和工作区，命令如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --filename 用缓存区filename文件覆盖工作区filename</span><br><span class="line">git checkout branch --filename 用branch中的filename文件覆盖工作区和缓存区的filename</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>建立一个提交<br> 终于在完成一个功能的开发之后可以进行版本迭代了，这个时候我们需要进行一次提交来将新写的代码从缓存区转移到版本库，这个过程就称为提交。提交的命令如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message] 普通提交，可以直接commit，之后在vim中填写message</span><br><span class="line">git commit [file1] [file2] 指定部分文件进行提交</span><br><span class="line">git commit -a 相当于git add . + git commit</span><br><span class="line">git commit -v 提交时显示所有diff信息</span><br></pre></td></tr></table></figure>
<p> 其中如果不加<code>-m</code>选项，则会跳出这么一个界面：<br> <img src="https://img-blog.csdnimg.cn/20210226111516658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于新手来说可能不知道这个界面是怎么回事，同时还发现无法操作。这个界面要求我们输入提交的信息（commit message），也就是带有<code>-m</code>选项中的后面的<code>[message]</code>。而当前处于的是一个叫做Vim的编辑器，这里只介绍最基础的操作，按下<code>i</code>即可开始编辑，编辑完成之后按下<code>ESC</code>结束编辑，再依次按下<code>:wq</code>回车结束即可。</p>
<p> 当然能够提交也要能够撤销提交，如果在一次提交之后发现有错误，那这时我们可以通过两种方式进行补救：</p>
<ol>
<li>覆盖法<br> 将需要修改的文件修改完成之后，重新添加到暂存区，之后通过<br> <code>git commit --amend</code>即可用一次新的提交来覆盖上一次提交，其中暂存区中同名的文件会被替换，而其他文件则保留在这个版本当中。</li>
<li>撤回法<br> 如果错误一时半会儿解决不了，则可以通过下面的命令撤回提交<br> <code>git reset --hard HEAD~1</code><br> 其中1也可以替换为任意数值，表示当前HEAD指向前的n个版本。</li>
</ol>
</li>
<li><p>总结<br> 以上的操作可以通过一张图简单的概括一下：<br><img src="https://img-blog.csdnimg.cn/20210226113737201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当然Git当中有许多相似的操作，他们可以针对不同的情况来使用，这里就不做过多介绍，感兴趣的话可以自行上网搜索。</p>
</li>
</ol>
<h3 id="4-2-分支操作"><a href="#4-2-分支操作" class="headerlink" title="4.2 分支操作"></a>4.2 分支操作</h3><p>在掌握了上面的基本操作之后，我们基本上就能够用Git来进行版本的控制管理了，但是在实际开发中，我们还会遇到多分支开发的情况，这时候就需要学习分支操作了。</p>
<ol>
<li><p>创建一个分支<br> 在创建Git仓库之后会默认生成一个<code>master</code>或<code>main</code>分支，而如果想要创建一个新的分支，可以通过<br> <code>git branch [branchname]</code><br> 实现。</p>
</li>
<li><p>切换分支<br> 在创建出新的分支之后，想要切换到这个分支去，可以用上面提到的<code>checkout</code>命令：<br> <code>git checkout [branchname]</code></p>
<p> 而创建切换两步其实可以通过一步来完成<br> <code>git checkout -b [branchname]</code>这样如果原来不存在<code>branchname</code>分支则会自动创建并切换过去。</p>
<p> <strong>注意</strong>：切换分支之后缓存区和工作区都会被新分支的最新提交所覆盖，所以在切换之前需要先把缓存区与工作区中刚刚完成的内容提交到分支当中，然后再进行切换，防止内容丢失。</p>
</li>
<li><p>分支合并</p>
<pre><code> 当你和你的小伙伴分别都完成了各自的开发内容后，现在需要将你们两个负责的分支合并起来变成完整的版本，这个时候就需要分支合并了。分支合并可以通过以下命令实现：
</code></pre>
<p> <code>git merge [branchname]</code><br> 这条命令会把<code>branchname</code>分支合并到当前所在分支当中，所以在合并之前要记得先切换分支哦。</p>
</li>
</ol>
<pre><code>当然了，分支的合并没有那么简单，加入你和你的小伙伴在开发过程中都对某一个文件做出了修改，合并的时候就会提示分支之间存在冲突（conflicts），冲突显示的方式与上文`diff`的样式相同，这个时候就需要你们进入文件，对冲突的部分进行协商然后进行修改了。 通常冲突会保留在文件当中，如下图所示
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021022611515863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70)
图中使用`&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; branchname``=========``&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchname`分隔开两个不同的分支中同一个区域的不同内容，我们在修改的时候可以选择保留其中一个，也可以两个都保留，最后记得删去分隔线，在冲突解决好之后，这时**不使用`merge`命令**，而是需要将这个修改后的文件添加到缓冲区，之后提交即可：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add [冲突文件]</span><br><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure>
在冲突解决之后右侧的状态会发生变化
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210226115832125.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210226115853256.png" alt="在这里插入图片描述"><br>    可以看到<code>MERGING</code>消失。</p>
<pre><code>当然除了`merge`命令之外，Git还提供了一个`rebase`命令也可以用于分支合并，`rebase`命令会将另一个分支的所有提交全部复制到新的分支上，从而在新的分支上产生许多新的提交，具体入下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227104222198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70)
关于二者的区别，[点击查看详情](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)
</code></pre>
<ol start="5">
<li>删除分支<br>在分支合并完成之后，原有的分支就不再需要了，这时可以通过：<br><code>git branch -d [branchname]</code>删除。<h3 id="4-3-应用操作"><a href="#4-3-应用操作" class="headerlink" title="4.3 应用操作"></a>4.3 应用操作</h3>在介绍完基本的操作之后，我们聚焦于应用类的操作，主要设计日常开发过程中的一些常见操作。<h4 id="4-3-1-多分支开发"><a href="#4-3-1-多分支开发" class="headerlink" title="4.3.1 多分支开发"></a>4.3.1 多分支开发</h4>在日常的开发过程当中，我们通常不会直接在<code>master</code>分支上直接进行迭代更新，而是会另外设置一些分支，常见的分支如下：</li>
</ol>
<ul>
<li>master分支：主分支，仅用于记录关键版本节点；</li>
<li>develop分支：开发分支，从master分支中分出，用于记录每个小的版本更新。</li>
<li>feature分支：从develop分支分出，用于开发某个小功能，开发完成后合并回develop分支。</li>
<li>hotfix分支：用于紧急修复，从master分支分出，修复完成后合并回master分支，然后再从把master分支合并到develop分支从而将修复内容也转移到develop分支。</li>
<li>release分支：用于版本发布，从develop分支分出，通常需要在这个分支上进行代码注释，相关文件的版本号修改，完成之后合并到master分支，再在master分支上打上tag，一次版本更新就完成了。<br>总结起来就是下图这样：<br><img src="https://img-blog.csdnimg.cn/20210227091919534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="4-3-2-代码回滚"><a href="#4-3-2-代码回滚" class="headerlink" title="4.3.2 代码回滚"></a>4.3.2 代码回滚</h4><p>代码回滚总共有3中类似但不同的命令，下面一一进行介绍：</p>
<ul>
<li><p>checkout：这个命令我们之前有提及过，这里进一步解释以下，这个命令主要是用于查看之前的某个提交，会将HEAD转移到之前的某个提交上，保持原来的版本库不变，具体可见下图：<br><img src="https://img-blog.csdnimg.cn/20210227094545953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227094601870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们输入<code>git checkout HEAD^^</code>，看到此时HEAD指针指向了前两个版本节点，但是整个版本库的树形结构没有发生改变。</p>
<p>  值得一提的是，这种方式虽然没有对树形结构进行破坏，但也正是如此，如果想要在这种情况下做出修改，我们不能简单地直接修改后提交，而是要另外再在这个节点上分出一个分支，修改提交之后再将这个分支合并回去，如下图所示。所以<code>checkout</code>命令才更主要用于查看而非修改。<br>  <img src="https://img-blog.csdnimg.cn/20210227095705742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>reset：与<code>checkout</code>相对，<code>reset</code>命令则会破坏原来的树状结构，会将该分支返回后的节点以后的所有节点删除掉，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20210227095853147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227095907288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>reset命令的作用就是更加纯粹的用于撤销之前的修改重新对之前的代码进行改动，可以看到相比<code>checkout</code>，<code>reset</code>在修改之后重新生成一个新的提交会方便很多。但是这样做的危害则是抛弃之前所做的一些修改，同时如果这个分支已经共享给了其他人，这么做很有可能会造成大量的冲突，甚至也有可能抹除他人所做的一些修改。</p>
</li>
<li><p>revert：revert命令算是随着Git的更新后来跟上的一个命令，这个命令主要是为了解决<code>reset</code>命令中存在的痛点，即无法在多人协作的项目中使用。<code>revert</code>相比<code>reset</code>的不同点在于它并不会“返回”之前的那个节点，而是把之前的一个节点挪到当前节点的下一个节点位置，然后再由你进行修改，详情可见下图：<br><img src="https://img-blog.csdnimg.cn/20210227100432455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227100448302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这么做在多人协作的项目中会有更好的效果，但是如果分支不需要和别人共享，那么这么做则会使Git历史记录变得冗余繁杂，同时也增大的存储占用。</p>
<h3 id="4-4-远程仓库"><a href="#4-4-远程仓库" class="headerlink" title="4.4 远程仓库"></a>4.4 远程仓库</h3><p>当我们需要一个团队一起合作完成任务的时候，我们就需要有一个共同的远程仓库来存放整个团队的代码了，下面我们就来介绍远程仓库的相关操作。</p>
</li>
</ul>
<ol>
<li><p>远程仓库建立<br> 通常我们会将远程仓库建立在代码托管平台，例如GitHub，Gitee等平台，这里以GitHub为例简单展示如何建立。</p>
<p> 左上角找到如下界面，点击New开始建立一个仓库<br><img src="https://img-blog.csdnimg.cn/20210227101608107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后填写上仓库名称，描述等内容，然后可以选择是公有（public）还是私有（private），注意个人仓库私有是免费的，但是团队仓库私有需要收费，如果不想付费的话可以考虑Gitee等其他平台。最后点击最下方create即可。<br><img src="https://img-blog.csdnimg.cn/20210227101736277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后会进入这样一个界面，将仓库的SSH地址复制下来，在命令行通过<code>git clone URL</code><strong>按下<code>Insert</code>键即可粘贴</strong>。<br><img src="https://img-blog.csdnimg.cn/20210227102010833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是也有可能出现下面这样的情况。这是因为GitHub网站还不认识你这台电脑，需要使用一个SSH密钥来指定你这台电脑，在你的GitHub网站中设置一下即可，<a target="_blank" rel="noopener" href="https://blog.csdn.net/dotphoenix/article/details/100130424">点击查看详情</a>。<br><img src="https://img-blog.csdnimg.cn/20210227102439297.png" alt="在这里插入图片描述"><br>当然如果你的电脑上安装了GitHub Desktop，则可以直接点击<code>Set up in Desktop</code>一键完成。</p>
</li>
<li><p>克隆<br>上面其实我们已经介绍了如何把自己建立的GitHub仓库克隆到自己的电脑上，其实就是通过<br><code>git clone URL</code><br>来实现的，这里再介绍一下如何克隆别人的仓库。<br><img src="https://img-blog.csdnimg.cn/20210227102905578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进入别人的仓库后会是这样的一个界面，点击绿色的按钮<code>Code</code>会出现如下界面。<br><img src="https://img-blog.csdnimg.cn/20210227102953352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击右边的按钮复制即可，其他同上。</p>
</li>
<li><p>抓取<br>当我们想要和远程仓库取得同步的时候，我们就需要使用抓取（fetch）和拉取（pull）两个命令。抓取的作用是从远程仓库获取它的所有版本库中的内容并用于更新本机的版本库，<strong>但是保留当前缓存区和工作区的内容</strong>，具体命令如下。其中<code>name</code>是远程仓库的名字，通常是origin，当然也可以自己进行设置。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch [name] [branch] 只抓取特定分支</span><br><span class="line">git fetch [name] 抓取所有分支</span><br></pre></td></tr></table></figure>
<p> 抓取到的分支会被命名为<code>name/branch</code>，之后如果要将当前的分支与远程分支进行合并，则可以通过<code>merge</code>或<code>rebase</code>命令实现。</p>
</li>
<li><p>拉取<br> 拉取相当于将抓取与合并两步合起来，具体命令如下：<br> <code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>   如果省略冒号后面的内容，则会与当前分支进行合并，同时在克隆的时候会自动建立和远程分支的跟踪关系，从而可以只保留远程主机名。当然跟踪关系也可以手动建立，通过<br>   <code>git branch --set-upstream [local_branch] [远程主机名/分支名]</code>实现。</p>
<p>   同时如果我们希望直接用远程分支来覆盖本地对应的追踪分支，可以通过如下命令：<br>   <code>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>
<p> <strong>注意</strong>：可能有人会有这样的疑惑，如果我在拉取的时候远程分支已经被删除了，一经同步岂不是也会把我的分支给删除吗？这里大家可以放心，一般情况下是不会被删除的，如果想删除，需要在命令中添加<code>-p</code>选项。</p>
</li>
<li><p>推送<br> 在完成了自己的任务之后，需要将自己的进度推送到远程主机上，这个时候就需要进行推送（push）了。命令如下：<br> <code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>  注意分支顺序和pull相反。同上如果省略远程分支名则会自动推送到存在追踪关系的分支，如果没有则会新建一个该名字的分支。如果省略本地分支名，则相当于删除某个远程分支。</p>
<p> 而如果只保留远程主机名，则自动将当前分支推送到与之有追踪关系的分支。</p>
<h2 id="5-Git团队开发规范Gitflow"><a href="#5-Git团队开发规范Gitflow" class="headerlink" title="5 Git团队开发规范Gitflow"></a>5 Git团队开发规范Gitflow</h2><p>Git这项工具在开发的时候并没有设定什么规范，但是我们在开发的过程中如果不遵守一定的规范则很容易导致错误，甚至会破坏整个团队的成果，所有就有人逐渐总结Git的使用方法，发明出了工作流的说法，这里我们就简单介绍一下Gitflow这一工作流的基本原则。</p>
</li>
<li><p><code>master</code>分支</p>
<p><code>master</code>分支应该是稳定的，可以轻松地被获取到然后编译使用，同时也是<code>hotfix</code>(热修复)分支的出发点。</p>
</li>
<li><p>develop分支</p>
<p><code>develop</code>分支是开发分支，代表开发的最前沿(bleeding edge)，在这个分支中分出<code>feature</code>分支用以开发新的功能。</p>
</li>
<li><p>不允许直接在<code>develop</code>和<code>maste</code>r分支上进行开发</p>
</li>
<li><p>分支名应该具有概括性，例如修补分支fix-xxxbug，release-X.X.X</p>
</li>
<li><p>在开发完一个<code>feature</code>分支之后，想要并入<code>develop</code>分支，首先要通过<code>pull</code>获取最新的<code>develop</code>分支并消除<code>conflicts</code></p>
<p>如果还没有将当前的这个<code>feature</code>分支传到远程主机（<code>feature</code>完全在本地），则首先将远程端的<code>develop</code>分支<code>rebase</code>到本地（相当于更新本地的<code>develop</code>分支），然后将<code>feature</code>分支<code>merge</code>到<code>develop</code>分支并解决冲突（这个步骤在本地完成），最后将<code>develop</code>分支<code>push</code>到远程主机，然后本地的<code>feature</code>分支就可以删除了。</p>
<p>而如果已经将这个<code>feature</code>分支传到远程主机（<code>feature</code>同时在本地和远程主机），则首先将<code>develop</code>分支<code>merge</code>到<code>feature</code>分支，然后再将<code>feature</code>分支<code>merge</code>到<code>develop</code>分支，最后推送到远程主机，并删除<code>feature</code>分支。</p>
</li>
<li><p>code review</p>
<p>Code review是指同事之间互相阅读代码并给出自己的意见或想法的过程。通过<code>pull request</code>来进行code review，同时让打开pull request的人来将分支合并到远程主机中，在原作者为同意意见之后由写code review的人将代码合并到主分支。</p>
<p>pull request会在其他人想要将自己的分支合并到远程主机的分支时提出，字面意思是提出者希望原作者能够将他们的分支pull到项目代码当中</p>
</li>
<li><p>在develop分支开发完成准备要发布的时候，首先需要将develop合并到master分支当中，注意此时合并的时候要带上<code>--no-ff</code>选项，从而避免合并出<code>fast-forward</code>类型。而新的提交可以打上X.X.X的tag，然后再将master合并到develop分支中，这样develop分支中也会有版本号的tag。</p>
</li>
</ol>
<p>​    <strong>什么是fast-forward：</strong></p>
<p>​    如下图<br><img src="https://img-blog.csdnimg.cn/2021022710550557.png#pic_center" alt="在这里插入图片描述"></p>
<p>​    当在master分支进行bugfix之后，现在要合并回去，如果原master分支没有更新，那么直接merge的话会变成下面这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20210227105416178.png#pic_center"></p>
<p>​    如果加上<code>--no-ff</code>选项    </p>
<p><img src="https://img-blog.csdnimg.cn/20210227105448219.png#pic_center" alt="在这里插入图片描述"></p>
<p>​    区别在于此时master分支直接移动到了bugfix这里，而没有形成一个新的提交，这里git是偷了一个懒。但是问题会出现在如果将这个bugfix分支删除掉的时候，如下两图所示：</p>
<p>这是直接merge</p>
<p><img src="https://img-blog.csdnimg.cn/20210227105357497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这是使用<code>--no-ff</code>选项。<br><img src="https://img-blog.csdnimg.cn/20210227105333313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTX05ld2VyMTk4ODU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>可以看到，非fast-forward的情况下会生成多一个提交在主分支上，这里就可以写上bug-fix，也能看到整个bug-fix的过程的提交信息，而如果不加，在删除掉之后就只剩下最后一次的bug-fix的提交信息，不利于后续的回滚。</p>
<ol start="8">
<li><p>bug-fix</p>
<p>在发现bug需要修改的时候，要从master分支中分出分支然后修改，修改完成后合并回去（注意–no-ff)，然后将master分支合并到develop分支。</p>
</li>
<li><p>Commit message</p>
<p>在写commit message的时候，使用一般现在时，不使用三单形式，第一行书写Summary，一般在50词以内，如果需要进一步说明则换行使用段落的格式进行，注意正确的标点和大小写，并且控制在72列以内就要换行。</p>
</li>
<li><p>release</p>
<p>release分支从develop分支中分出，首先生成一个新的分支release-X.X，（然后通过一个固定脚本将代码中的版本号统一进行修改），然后git commit -a即可，之后切换回master分支，在这里用–no-ff合并刚刚的release分支到master分支，然后通过git tag -a X.X打上tag，最后将release分支删除即可。</p>
</li>
</ol>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>Git的使用是团队开发过程中难以避免的一环，正确的使用Git可以为开发节省下大量的精力，但同时错误地使用也可能造成整个团队项目的崩溃，所以对Git的学习使用一定要规范正确，多加练习，才能在真正需要的时候发挥出它的强大威力。</p>
<h3 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7 参考资料"></a>7 参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud">Learn git</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/best/p/7474442.html">一小时学会Git</a></li>
<li><a target="_blank" rel="noopener" href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model
</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Git/" data-id="ckmpminms0006b8v8c03l1vpt" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-My-First-Blog" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/My-First-Blog/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T01:22:37.000Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/26/My-First-Blog/">My First Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/26/My-First-Blog/" data-id="ckmpmfcoq0000ekv8gbj423it" data-title="My First Blog" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Others/" rel="tag">Others</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:16:35.082Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/hello-world/" data-id="ckmn239880000e4v8f9nfc3l2" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Others/" rel="tag">Others</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Others/" style="font-size: 10px;">Others</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E6%AF%94%E8%B5%9B%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%E7%AE%80%E4%BB%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/26/Robocup2D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94agent2d%E7%90%83%E9%98%9F%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/26/Robpcup%202D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E5%8F%8A%E5%90%8E%E7%BB%AD/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Yikai-coder<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>